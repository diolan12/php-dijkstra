<?php

namespace Diolan12;

/**
 * A class that represents a network of cable routes.
 * Generated by OpenAI ChatGPT [Mar 14 Version](https://help.openai.com/en/articles/6825453-chatgpt-release-notes)
 */
class Dijkstra
{
    private $prefix = '#';
    private $vertices = [];

    public function __construct($graph = [])
    {
        $prefixedVertices = [];
        foreach ($graph as $k => $edges) {
            $prefixedName = $this->setPrefix($k);
            $prefixedVertices[$prefixedName] = [];
            foreach ($edges as $edgeKey => $edgeValue) {
                $prefixedVertices[$prefixedName][$this->setPrefix($edgeKey)] = $edgeValue;
            }
        }
        $this->vertices = $prefixedVertices;
    }

    private function setPrefix(string $value)
    {
        return $this->prefix . $value;
    }
    private function unPrefix(string $value)
    {
        return substr($value, 1);
    }

    /**
     * Return Dijkstra's instance
     * @return \Diolan12\Dijkstra
     */
    public static function instance($graph = [])
    {
        return new self($graph);
    }

    /**
     * Add a vertex to the graph with its neighboring edges.
     *
     * @param string $name The name of the vertex.
     * @param array $edges An associative array representing the neighboring vertices and their edge weights.
     * @return \Diolan12\Dijkstra
     */
    public function addVertex($name, $edges)
    {
        $prefixedName = [];
        foreach ($edges as $key => $value) {
            $prefixedName[$this->setPrefix($key)] = $value;
        }
        $this->vertices[$this->setPrefix($name)] = $prefixedName;
        return $this;
    }

    /**
     * Add an edge between two vertices with a given weight.
     *
     * @param string $src The source vertex.
     * @param string $dest The destination vertex.
     * @param int $weight The weight or cost of the edge.
     * @return \Diolan12\Dijkstra
     */
    public function addEdge($src, $dest, $weight, $reversible = false)
    {
        $this->vertices[$this->setPrefix($src)][$this->setPrefix($dest)] = $weight;
        if ($reversible) {
            $this->vertices[$this->setPrefix($dest)][$this->setPrefix($src)] = $weight;
        }
        return $this;
    }

    /**
     * Dijkstra's shortest path algorithm
     * [Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
     * @see https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
     * @throws \Diolan12\NoPathException
     */
    public function findShortestPath($start, $end)
    {
        $start = $this->setPrefix($start);
        $end = $this->setPrefix($end);
        $distances = [];
        $visited = [];
        $previous = [];

        foreach ($this->vertices as $vertex => $edges) {
            $distances[$vertex] = INF;
            $visited[$vertex] = false;
            $previous[$vertex] = null;
        }

        $distances[$start] = 0;

        if (!isset($visited[$end])) {
            throw new NoPathException('Route not found "' . $this->unPrefix($end) . '"');
        }
        while ($visited[$end] === false) {
            $current = null;
            $minDist = INF;

            foreach ($distances as $vertex => $dist) {
                if (array_key_exists($vertex, $visited)){
                    if ($visited[$vertex] === false && $dist <= $minDist) {
                        $minDist = $dist;
                        $current = $vertex;
                    }
                } else throw new NoPathException('Edge "' . $this->unPrefix($vertex) . '" not found');
            }

            foreach ($this->vertices[$current] as $neighbor => $cost) {
                $alt = $distances[$current] + $cost;

                if ($alt < $distances[$neighbor]) {
                    $distances[$neighbor] = $alt;
                    $previous[$neighbor] = $current;
                }
            }

            $visited[$current] = true;
        }

        $path = [];
        $current = $end;

        while ($current !== $start) {
            if ($current == null) {
                throw new NoPathException('Route not found "' . $this->unPrefix($end) . '"');
            }
            array_unshift($path, $current);
            $current = $previous[$current];
        }

        array_unshift($path, $start);

        foreach ($path as $k => $p) {
            $path[$k] = $this->unPrefix($p);
        }

        return $path;
    }
}
